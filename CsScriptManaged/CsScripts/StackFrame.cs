using CsScriptManaged;
using CsScriptManaged.Utility;
using Microsoft.Diagnostics.Runtime.Interop;
using System;

namespace CsScripts
{
    /// <summary>
    /// Stack frame of the process being debugged.
    /// </summary>
    public class StackFrame
    {
        /// <summary>
        /// The frame
        /// </summary>
        private DEBUG_STACK_FRAME_EX frame;

        /// <summary>
        /// The source file name, line and displacement
        /// </summary>
        private SimpleCache<Tuple<string, uint, ulong>> sourceFileNameAndLine;

        /// <summary>
        /// The function name and displacement
        /// </summary>
        private SimpleCache<Tuple<string, ulong>> functionNameAndDisplacement;

        /// <summary>
        /// The local variables
        /// </summary>
        private SimpleCache<VariableCollection> locals;

        /// <summary>
        /// The user type converted local variables
        /// </summary>
        private SimpleCache<VariableCollection> userTypeConvertedLocals;

        /// <summary>
        /// The arguments
        /// </summary>
        private SimpleCache<VariableCollection> arguments;

        /// <summary>
        /// The user type converted arguments
        /// </summary>
        private SimpleCache<VariableCollection> userTypeConvertedArguments;

        /// <summary>
        /// Initializes a new instance of the <see cref="StackFrame" /> class.
        /// </summary>
        /// <param name="stackTrace">The stack trace.</param>
        /// <param name="frame">The frame.</param>
        /// <param name="frameContext">The frame context.</param>
        internal StackFrame(StackTrace stackTrace, DEBUG_STACK_FRAME_EX frame, ThreadContext frameContext)
        {
            StackTrace = stackTrace;
            FrameContext = frameContext;
            this.frame = frame;
            sourceFileNameAndLine = SimpleCache.Create(ReadSourceFileNameAndLine);
            functionNameAndDisplacement = SimpleCache.Create(ReadFunctionNameAndDisplacement);
            locals = SimpleCache.Create(() => Context.SymbolProvider.GetFrameLocals(this, false));
            arguments = SimpleCache.Create(() => Context.SymbolProvider.GetFrameLocals(this, true));
            userTypeConvertedLocals = SimpleCache.Create(() =>
            {
                VariableCollection collection = Variable.CastVariableCollectionToUserType(locals.Value);

                GlobalCache.UserTypeCastedVariableCollections.Add(userTypeConvertedLocals);
                return collection;
            });
            userTypeConvertedArguments = SimpleCache.Create(() =>
            {
                VariableCollection collection = Variable.CastVariableCollectionToUserType(arguments.Value);

                GlobalCache.UserTypeCastedVariableCollections.Add(userTypeConvertedArguments);
                return collection;
            });
        }

        /// <summary>
        /// Gets or sets the current stack frame in current thread of current process.
        /// </summary>
        public static StackFrame Current
        {
            get
            {
                return Context.Debugger.GetThreadCurrentStackFrame(Thread.Current);
            }

            set
            {
                Context.Debugger.SetCurrentStackFrame(value);
            }
        }

        /// <summary>
        /// Gets the owning stack trace.
        /// </summary>
        public StackTrace StackTrace { get; internal set; }

        /// <summary>
        /// Gets the frame context.
        /// </summary>
        public ThreadContext FrameContext { get; private set; }

        /// <summary>
        /// Gets the owning thread.
        /// </summary>
        public Thread Thread
        {
            get
            {
                return StackTrace.Thread;
            }
        }

        /// <summary>
        /// Gets the owning process.
        /// </summary>
        public Process Process
        {
            get
            {
                return Thread.Process;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this <see cref="StackFrame"/> is virtual.
        /// </summary>
        /// <value>
        ///   <c>true</c> if this stack frame was generated by the debugger by unwinding; otherwise, <c>false</c> if it
        ///   was formed from a thread's current context. Typically, this is <c>true</c> for the frame at the top of the
        ///   stack, where InstructionOffset is the current instruction pointer.
        /// </value>
        public bool Virtual
        {
            get
            {
                return frame.Virtual != 0;
            }
        }

        /// <summary>
        /// Gets the index of the frame. This index counts the number of frames from the top of the call stack.
        /// The frame at the top of the stack, representing the current call, has index zero..
        /// </summary>
        public uint FrameNumber
        {
            get
            {
                return frame.FrameNumber;
            }
        }

        /// <summary>
        /// Gets the location in the process's virtual address space of the stack frame, if known.
        /// Some processor architectures do not have a frame or have more than one. In these cases,
        /// the engine chooses a value most representative for the given level of the stack.
        /// </summary>
        public ulong FrameOffset
        {
            get
            {
                return frame.FrameOffset;
            }
        }

        /// <summary>
        /// Gets the location in the process's virtual address space of the related instruction for the stack frame.
        /// This is typically the return address for the next stack frame, or the current instruction pointer if the
        /// frame is at the top of the stack. 
        /// </summary>
        public ulong InstructionOffset
        {
            get
            {
                return frame.InstructionOffset;
            }
        }

        /// <summary>
        /// Gets the location in the process's virtual address space of the return address for the stack frame.
        /// This is typically the related instruction for the previous stack frame.
        /// </summary>
        public ulong ReturnOffset
        {
            get
            {
                return frame.ReturnOffset;
            }
        }

        /// <summary>
        /// Gets the location in the process's virtual address space of the processor stack.
        /// </summary>
        public ulong StackOffset
        {
            get
            {
                return frame.StackOffset;
            }
        }

        /// <summary>
        /// Gets the name of the source file.
        /// </summary>
        public string SourceFileName
        {
            get
            {
                return sourceFileNameAndLine.Value.Item1;
            }
        }

        /// <summary>
        /// Gets the source file line.
        /// </summary>
        public uint SourceFileLine
        {
            get
            {
                return sourceFileNameAndLine.Value.Item2;
            }
        }

        /// <summary>
        /// Gets the source file displacement.
        /// </summary>
        public ulong SourceFileDisplacement
        {
            get
            {
                return sourceFileNameAndLine.Value.Item3;
            }
        }

        /// <summary>
        /// Gets the name of the function (including module name).
        /// </summary>
        public string FunctionName
        {
            get
            {
                return functionNameAndDisplacement.Value.Item1;
            }
        }

        /// <summary>
        /// Gets the function name without module name.
        /// </summary>
        public string FunctionNameWithoutModule
        {
            get
            {
                int moduleEnd = FunctionName.IndexOf('!');

                return moduleEnd >= 0 ? FunctionName.Substring(moduleEnd + 1) : FunctionName;
            }
        }

        /// <summary>
        /// Gets the function displacement.
        /// </summary>
        public ulong FunctionDisplacement
        {
            get
            {
                return functionNameAndDisplacement.Value.Item2;
            }
        }

        /// <summary>
        /// Gets the local variables.
        /// </summary>
        public VariableCollection Locals
        {
            get
            {
                return userTypeConvertedLocals.Value;
            }
        }

        /// <summary>
        /// Gets the function arguments.
        /// </summary>
        public VariableCollection Arguments
        {
            get
            {
                return userTypeConvertedArguments.Value;
            }
        }

        /// <summary>
        /// Reads the name of the source file, line and displacement.
        /// </summary>
        /// <exception cref="System.AggregateException">Couldn't read source file name. Check if symbols are present.</exception>
        private Tuple<string, uint, ulong> ReadSourceFileNameAndLine()
        {
            try
            {
                string sourceFileName;
                uint sourceFileLine;
                ulong displacement;

                Context.SymbolProvider.GetStackFrameSourceFileNameAndLine(this, out sourceFileName, out sourceFileLine, out displacement);
                return Tuple.Create(sourceFileName, sourceFileLine, displacement);
            }
            catch (Exception ex)
            {
                throw new AggregateException("Couldn't read source file name. Check if symbols are present.", ex);
            }
        }

        /// <summary>
        /// Reads the function name and displacement.
        /// </summary>
        /// <returns></returns>
        /// <exception cref="System.AggregateException">Couldn't read source file name. Check if symbols are present.</exception>
        private Tuple<string, ulong> ReadFunctionNameAndDisplacement()
        {
            try
            {
                ulong displacement;
                string functionName;

                Context.SymbolProvider.GetStackFrameFunctionName(this, out functionName, out displacement);
                return Tuple.Create(functionName, displacement);
            }
            catch (Exception ex)
            {
                throw new AggregateException("Couldn't read function name. Check if symbols are present.", ex);
            }
        }
    }
}
